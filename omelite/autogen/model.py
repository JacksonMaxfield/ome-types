from textwrap import dedent, indent, wrap
from typing import Set

from xmlschema import validators

from .attribute import AttributeConverter
from .component import ComponentConverter
from .element import ElementConverter
from .util import black_format, props_sorter, sort_imports


class ModelConverter(ComponentConverter):
    def __init__(self, component: validators.XsdElement):
        self.component = component
        self.clear()

    def clear(self) -> None:
        self._imports: Set[str] = set(["from pydantic.dataclasses import dataclass "])
        self._attributes: Set[AttributeConverter] = set()
        self._children: Set[ElementConverter] = set()
        self._locals: Set[str] = set()

    def gather(self) -> None:
        if self.is_extension and self.base_type.is_complex():
            base_attrs = self.base_type.attributes
            base_elems = list(
                filter(
                    lambda x: isinstance(x, validators.XsdElement),
                    self.base_type.iter_components(),
                )
            )
        else:
            base_attrs = []
            base_elems = []

        for attr in self.component.attributes.values():
            if attr.local_name in base_attrs:
                continue
            atconv = AttributeConverter(attr)
            self._imports.update(atconv.get_imports())
            self._attributes.add(atconv)
            self._locals.update(atconv.get_locals())
        for child in self.component.iterchildren():
            if child in base_elems:
                continue
            elconv = ElementConverter(child)
            self._imports.update(elconv.get_imports())
            self._children.add(elconv)
            self._locals.update(elconv.get_locals())

    @property
    def docstring(self) -> str:
        try:
            doc = dedent(self.component.annotation.documentation[0].text)
            doc = "\n".join(wrap(dedent(doc).strip()))
            doc = f'"""{doc}\n"""\n'
            return doc
        except (AttributeError, IndexError):
            return ""

    @property
    def is_extension(self) -> bool:
        return self.component.type.is_extension()

    @property
    def base_type(self):
        return self.component.type.base_type

    def dataclass(self) -> str:
        dataclass = ""
        attributes = list(self._attributes)
        base_type = self.component.type.base_type
        if self.is_extension and base_type.is_complex():
            dataclass += f"from .types import {base_type.local_name}\n\n"
            attributes = [
                a
                for a in attributes
                if a.component.local_name not in base_type.attributes
            ]

        dataclass += "@dataclass\n"
        base = f"({base_type.local_name})" if base_type else ""
        dataclass += f"class {self.component.local_name}{base}:\n"
        dataclass += indent(self.docstring, "    ")
        members = list(map(str, attributes)) + list(map(str, self._children))
        # required attributes at the top
        dataclass += indent("\n".join(sorted(members, key=props_sorter)), "    ")
        return dataclass

    def imports(self) -> str:
        return "\n".join(self._imports)

    def locals(self) -> str:
        return "\n".join(self._locals)

    def format(self) -> str:

        self.clear()
        self.gather()

        text = "\n".join([self.imports(), self.locals(), self.dataclass()])

        text = sort_imports(text)

        try:
            model_text = black_format(text)
        except Exception as e:
            raise ValueError(f"black failed on {self.component.local_name}: {e}")
        return model_text

    def __str__(self) -> str:
        text = f'"""\nAutogenerated model for {self.component.prefixed_name}\n"""\n'
        text += self.format()
        return text
